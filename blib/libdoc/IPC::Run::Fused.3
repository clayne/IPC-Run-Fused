.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.23)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "IPC::Run::Fused 3"
.TH IPC::Run::Fused 3 "2013-02-05" "perl v5.17.9" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
IPC::Run::Fused \- Capture Stdout/Stderr simultaneously as if it were one stream, painlessly.
.SH "VERSION"
.IX Header "VERSION"
version 0.04000100
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use IPC::Run::Fused qw( run_fused );
\&
\&  run_fused( my $fh, $stderror_filled_program, \*(Aq\-\-file\*(Aq, $tricky_filename, @moreargs ) || die "Argh $@";
\&  open my $fh, \*(Aq>\*(Aq, \*(Aqsomefile.txt\*(Aq || die "NOO  $@";
\&
\&  # Simple implementation of \*(Aqtee\*(Aq like behaviour,
\&  # sending to stdout and to a file.
\&
\&  while ( my $line = <$fh> ) {
\&    print $fh $line;
\&    print $line;
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Have you ever tried to do essentially the same as you would in bash do to this:
.PP
.Vb 1
\&  parentapp <( app 2>&1  )
.Ve
.PP
And found massive road works getting in the way.
.PP
Sure, you can aways do this style syntax:
.PP
.Vb 1
\&  open my $fh, \*(Aqsomeapp \-\-args foo 2>&1 |\*(Aq;
.Ve
.PP
But thats not very nice, because
.IP "1. you're relying on a subshell to do that for you" 4
.IX Item "1. you're relying on a subshell to do that for you"
.PD 0
.IP "2. you have to manually escape everything" 4
.IX Item "2. you have to manually escape everything"
.IP "3. you can't use list context." 4
.IX Item "3. you can't use list context."
.PD
.PP
And none of this is very \fBModern\fR or \fBNice\fR
.SH "SIMPLEST THING THAT JUST WORKS"
.IX Header "SIMPLEST THING THAT JUST WORKS"
This code is barely tested, its here, because I spent hours griping about how the existing ways suck.
.SH "FEATURES"
.IX Header "FEATURES"
.IP "1. No String Interpolation." 4
.IX Item "1. No String Interpolation."
Arguments after the first work as if you'd passed them directly to 'system'. You can be as dangerous or as
safe as you want with them. We recommend passing a list, but a string ( as a scalar reference ) should work
.Sp
But if you're using a string, this modules probably not affording you much.
.IP "2. No dicking around with managing multiple file handles yourself." 4
.IX Item "2. No dicking around with managing multiple file handles yourself."
I looked at IPC::Run IPC::Run3 and IPC::Open3, and they all seemed very unfriendly, and none did what I wnted.
.IP "3. Non-global filehandles supported by design." 4
.IX Item "3. Non-global filehandles supported by design."
All the competition seem to still have this thing for global file handles and you having to use them. Yuck!.
.Sp
We have a few global \s-1FH\s0's inside our code, but they're only \s-1STDERR\s0 and \s-1STDOUT,\s0 at present I don't think I can circumvent that. If I ever can, I'll endeavour to do so =)
.SH "EXPORTED FUNCTIONS"
.IX Header "EXPORTED FUNCTIONS"
No functions are exported by default, be explicit with what you want.
.PP
At this time there is only one, and there are no plans for more.
.SS "run_fused"
.IX Subsection "run_fused"
.Vb 3
\&  run_fused( $fh, $executable, @params ) || die "$@";
\&  run_fused( $fh, \e$command_string )     || die "$@";
\&  run_fused( $fh, sub { .. } )           || die "$@";
\&
\&  # Recommended
\&
\&  run_fused( my $fh, $execuable, @params ) || die "$@";
\&
\&  # Somewhat supported
\&
\&  run_fused( my $fh, \e$command_string ) || die "$@";
.Ve
.PP
\&\f(CW$fh\fR will be clobbered like 'open' does, and \f(CW$cmd\fR, \f(CW@args\fR will be passed, as-is, through to \fIexec()\fR or \fIsystem()\fR.
.PP
\&\f(CW$fh\fR will point to an IO::Handle attached to the end of a pipe running back to the called application.
.PP
the command will be run in a fork, and stderr and stdout \*(L"fused\*(R" into a singluar pipe.
.PP
\&\fB\s-1NOTE:\s0\fR at present, \s-1STDIN\s0's \s-1FD\s0 is left unchanged, and child processes will inherit parent \s-1STDIN\s0's, and will thus block ( somewhere ) waiting for response.
.SH "AUTHOR"
.IX Header "AUTHOR"
Kent Fredric <kentnl@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2013 by Kent Fredric.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
